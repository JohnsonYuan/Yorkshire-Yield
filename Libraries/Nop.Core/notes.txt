Convert code to HTML 4.01
Nop.Core\Html\CodeFormatter使用的是:
http://www.manoli.net/csharpformat/format.aspx
可以学习很多好的正则 (?<inner>(.*?)) 捕获(.*?)group名字为inner（roupg） regexCode2 = new Regex(@"\[code\](?<inner>(.*?))\[/code\]", RegexOptions.Compiled | RegexOptions.IgnoreCase);
build.cmd =》 cmd格式可以学习

[MethodImpl(MethodImplOptions.Synchronized)]属性加到方法 相当于lock(this)

Autofac Registration : http://docs.autofac.org/en/latest/register/registration.html
1. 如果注册相同的，后注册的生效
            builder.RegisterType<MyComponent>();
            builder.Register(c => new MyComponent()); //这个会生效， Resolve时候出来的是这个

2. builder.RegisterType<SomeType>(); 这样注册相当于builder.RegisterType<SomeType>().AsSelf();
Resolve<SomeType>即可
// However, if you want BOTH services (not as common) you can say so:
builder.RegisterType<SomeType>().AsSelf().As<IService>();
如果没有AsSelf() Resolve<SomeType> -> throw exception

// Create the builder with which components/services are registered.
var builder = new ContainerBuilder();

// Register types that expose interfaces...
builder.RegisterType<ConsoleLogger>().As<ILogger>();

// Register instances of objects you create...
var output = new StringWriter();
builder.RegisterInstance(output).As<TextWriter>();

// Register expressions that execute to create objects... 相当于RegisterInstance
builder.Register(c => new ConfigReader("mysection")).As<IConfigReader>();

// Build the container to finalize registrations
// and prepare for object resolution.
var container = builder.Build();

// Now you can resolve services using Autofac. For example,
// this line will execute the lambda expression registered
// to the IConfigReader service.
using(var scope = container.BeginLifetimeScope())
{
  var reader = container.Resolve<IConfigReader>();
}

Autofac per-request lifetime scope: http://docs.autofac.org/en/latest/faq/per-request-scope.html#registering-dependencies-as-per-request
InstancePerRequest vs InstancePerLifetimescope:
InstancePerMatchingLifetimeScope相当于一个有名字的InstancePerLifetimescope
InstancePerRequest 相当于一个名字为MatchingScopeLifetimeTags.RequestLifetimeScopeTag的InstancePerLifetimescope

InstancePerRequest https://github.com/autofac/Autofac/blob/41044d7d1a4fa277c628021537d5a12016137c3b/src/Autofac/RegistrationExtensions.cs
	var tags = new[] { MatchingScopeLifetimeTags.RequestLifetimeScopeTag }.Concat(lifetimeScopeTags).ToArray();
	return registration.InstancePerMatchingLifetimeScope(tags);

Reflection Components: RegisterType 的类型必须是concrete type
public class MyComponent
{
    public MyComponent() { /* ... */ }
    public MyComponent(ILogger logger) { /* ... */ }
    public MyComponent(ILogger logger, IConfigReader reader) { /* ... */ }
}

var builder = new ContainerBuilder();
builder.RegisterType<MyComponent>();
builder.RegisterType<ConsoleLogger>().As<ILogger>();
var container = builder.Build();
using(var scope = container.BeginLifetimeScope())
{
// autofac会发现ILogger已经注册， 所以resolve MyComponent的时候会选择MyComponent(ILogger logger)这个版本
  var component = container.Resolve<MyComponent>();
}

如果builder.Register(c => new MyComponent());
Resolve的时候是MyComponent() -》 即注册时使用的（类似于RegisterInstance)


Autofac MVC (Install-Package  Autofac.Mvc5)
register your controllers, and set the dependency resolver
http://docs.autofac.org/en/latest/integration/mvc.html
demo: http://blog.csdn.net/lhfly/article/details/7450781
http://www.codeproject.com/Articles/560798/ASP-NET-MVC-controller-dependency-injection-for-be
(RegisterControllers, SetResolver两步都是必须的, 否则找不到constructor)

1. Register Controllers(RegisterControllers同意注册， 要么单个注册):
	var builder = new ContainerBuilder();

	// You can register controllers all at once using assembly scanning...
	builder.RegisterControllers(typeof(MvcApplication).Assembly);

	// ...or you can register individual controlllers manually.
	builder.RegisterType<HomeController>().InstancePerRequest();
	builder.RegisterType<HomeController>().WithParameter("logger", new DefaultLogger()).InstancePerRequest();

Note that ASP.NET MVC requests controllers by their concrete types, so registering them As<IController>() is incorrect. 
Also, if you register controllers manually and choose to specify lifetimes, you must register them as InstancePerDependency() or InstancePerRequest()
 - ASP.NET MVC will throw an exception if you try to reuse a controller instance for multiple requests.

2. Set the Dependency Resolver (** This is for controller constructor injection **)
  // Set the dependency resolver to be Autofac.
  var container = builder.Build();
  DependencyResolver.SetResolver(new AutofacDependencyResolver(container));

 第一步注册Controller功能： 免去一个个注册Controller, 一次把assemblies中所有Controller注册
 example中给的参数是typeof(MvcApplication).Assembly， 会注册所有MvcApplication Assembly下的Controller
 NopCommerce中参数给的是typeFinder.GetAssemblies()， 会把AppDomain.Current所有引用中的Controller注册， 因为除了Nop.Web, Nop.Web.Framework还有Controller, 不能只注册web projet的assembly的controller
 把assemblies中继承IController的类注册RegistrationBuilder.ForType(t) 这样就能Resolve 所有的Controller了
 1. RegisterControllers source code: (Autofac.Mvc)
 https://github.com/autofac/Autofac/blob/41044d7d1a4fa277c628021537d5a12016137c3b/src/Autofac/Features/Scanning/ScanningRegistrationExtensions.cs
 
 return builder.RegisterAssemblyTypes(controllerAssemblies)
                .Where(t => typeof(IController).IsAssignableFrom(t) &&
                    t.Name.EndsWith(nameof(Controller), StringComparison.Ordinal));
2. builder.RegisterAssemblyTypes 在 Autofac RegistrationExtensions定义
return ScanningRegistrationExtensions.RegisterAssemblyTypes(builder, assemblies);
3. ScanningRegistrationExtensions source:
https://github.com/autofac/Autofac/blob/41044d7d1a4fa277c628021537d5a12016137c3b/src/Autofac/Features/Scanning/ScanningRegistrationExtensions.cs
assembly中每个类型都会RegistrationBuilder.ForType(t) // 注册当前Type, 相当于RegisterType<t>().AsSelf()


Use MemoryCache:(System.Web.Caching.Cache can only works in ASP.NET)
http://www.codeproject.com/Articles/290935/Using-MemoryCache-in-Net-4-0

Buildmanger.AddReference只能 
This method can only be called during the application's pre-start initialization phase. Use PreApplicationStartMethodAttribute to declare a method that will be invoked in that phase. 

// 属性写上class名称， 还有执行的方法， 方法必须是public static
[assembly: PreApplicationStartMethod(typeof(PluginManager), "Initialize")]
namespace Nop.WebApp.Demo
{
    /// <summary>
    /// Sets the application up for the plugin referencing
    /// </summary>
    public class PluginManager
    {
        public static void Initialize()
        {

        }
    }
}