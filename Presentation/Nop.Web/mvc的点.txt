可以总结:
DataAnnotationsModelMetadataProvider http://aspnetwebstack.codeplex.com/SourceControl/latest#src/System.Web.Mvc/DataAnnotationsModelMetadataProvider.cs
作用是读取属性HiddenInput, UIHint, Editable, DataType, DisplayFormat, SetFromDataTypeAndDisplay, ScaffoldColumn, Display,DisplayName, Required属性, 赋值到 DataAnnotationsModelMetadata result
如:
DisplayNameAttribute displayNameAttribute = attributeList.OfType<DisplayNameAttribute>().FirstOrDefault();
                if (displayNameAttribute != null)
                {
                    result.DisplayName = displayNameAttribute.DisplayName;
                }


ModelMetadataProviders.Current = new NopMetadataProvider();
NopMetadataProvider继承DataAnnotationsModelMetadataProvider,会把属性中是类型IModelAttribute的属性找出来,
metadata.AdditionalValues.Add(additionalValue.Name, additionalValue);
例如:
Nop.Web.Framework有属性:
NopResourceDisplayName : System.ComponentModel.DisplayNameAttribute, IModelAttribute

某个model属性
[NopResourceDisplayName("Admin.Catalog.Products.List.SearchProductName")]
public string SearchProductName { get; set; }

使用的时候调用:
@Html.NopLabelFor(model => model.SearchProductName)
可以取得属性(Nop.Web.Framework\HtmlExtensions.cs):
metadata.AdditionalValues.TryGetValue("NopResourceDisplayName", out value)
生成自定义的html
<div class="label-wrapper">
    <label class="control-label" for="SearchProductName" title="">Product name</label>
    <!--如果resourcekey + ".Hint" 可以在localization 中找到则生成下面这行-->
    <div class="ico-help" title="A product name."><i class="fa fa-question-circle"></i>
    </div>
</div>

Action:
NonAction
ChildAcion

Nop.Web.Framework.Seo、GenericPathRoute.cs中
data.Values["controller"] = "Product";
data.Values["action"] = "ProductDetails";
data.Values["productid"] = urlRecord.EntityId;
data.Values["SeName"] = urlRecord.Slug;
当前razor view中获取controller，action
Url.RequestContext.RouteData.Values["controller"].ToString()
Url.RequestContext.RouteData.Values["action"].ToString()
Url.RequestContext.RouteData.Values["categoryId"]

Filter:

_ViewStart.cshtml

View Vs Partial View (最下方有总结的比较表格):
http://www.c-sharpcorner.com/UploadFile/ff2f08/partial-view-in-mvc/


@Html.Partial 调用的RenderPartialInternal ==> FindPartialView是当前viewengine的方法
http://aspnetwebstack.codeplex.com/SourceControl/latest#src/System.Web.Mvc/HtmlHelper.cs
internal virtual void RenderPartialInternal(string partialViewName, ViewDataDictionary viewData, object model, TextWriter writer, ViewEngineCollection viewEngineCollection)
        {
            if (String.IsNullOrEmpty(partialViewName))
            {
                throw new ArgumentException(MvcResources.Common_NullOrEmpty, "partialViewName");
            }

            ViewDataDictionary newViewData = null;

            if (model == null)
            {
                if (viewData == null)
                {
                    newViewData = new ViewDataDictionary(ViewData);
                }
                else
                {
                    newViewData = new ViewDataDictionary(viewData);
                }
            }
            else
            {
                if (viewData == null)
                {
                    newViewData = new ViewDataDictionary(model);
                }
                else
                {
                    newViewData = new ViewDataDictionary(viewData) { Model = model };
                }
            }

            ViewContext newViewContext = new ViewContext(ViewContext, ViewContext.View, newViewData, ViewContext.TempData, writer);
            IView view = FindPartialView(newViewContext, partialViewName, viewEngineCollection);
            view.Render(newViewContext, writer);
        }

得到input的id
@Html.HiddenFor(model => model.Id)
可以调用：
@Html.IdFor(model => model.Id)
NopCommerce中使用@Html.FieldIdFor(model => model.Id), 扩展了HtmlHelper<T>
二者没有本质差别， nopcommerce替换了[, ] (不知道有什么用)

public static string FieldIdFor<T, TResult>(this HtmlHelper<T> html, Expression<Func<T, TResult>> expression)
{
    var id = html.ViewData.TemplateInfo.GetFullHtmlFieldId(ExpressionHelper.GetExpressionText(expression));
    // because "[" and "]" aren't replaced with "_" in GetFullHtmlFieldId
    return id.Replace('[', '_').Replace(']', '_');
}

和IdFor源码对比 http://aspnetwebstack.codeplex.com/SourceControl/latest#src/System.Web.Mvc/Html/NameExtensions.cs
public static MvcHtmlString Id(this HtmlHelper html, string name)
{
    return MvcHtmlString.Create(html.AttributeEncode(html.ViewData.TemplateInfo.GetFullHtmlFieldId(name)));
}
public static MvcHtmlString IdFor<TModel, TProperty>(this HtmlHelper<TModel> html, Expression<Func<TModel, TProperty>> expression)
{
    return Id(html, ExpressionHelper.GetExpressionText(expression));
}

ViewBag 如何 wrap ViewData
WebViewPage.cs http://aspnetwebstack.codeplex.com/SourceControl/latest#src/System.Web.Mvc/WebViewPage.cs
private ViewDataDictionary _viewData;
private DynamicViewDataDictionary _dynamicViewData;
public dynamic ViewBag
{
    get
    {
        if (_dynamicViewData == null)
        {
            _dynamicViewData = new DynamicViewDataDictionary(() => ViewData);
        }
        return _dynamicViewData;
    }
}
再看DynamicViewDataDictionary : 继承DynamicObject, 重写TryGetMember，TrySetMember 实现对ViewData操作
    internal sealed class DynamicViewDataDictionary : DynamicObject
    {
        private readonly Func<ViewDataDictionary> _viewDataThunk;

        public DynamicViewDataDictionary(Func<ViewDataDictionary> viewDataThunk)
        {
            _viewDataThunk = viewDataThunk;
        }

        private ViewDataDictionary ViewData
        {
            get
            {
                ViewDataDictionary viewData = _viewDataThunk();
                Debug.Assert(viewData != null);
                return viewData;
            }
        }

        // Implementing this function improves the debugging experience as it provides the debugger with the list of all
        // the properties currently defined on the object
        public override IEnumerable<string> GetDynamicMemberNames()
        {
            return ViewData.Keys;
        }

        public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            result = ViewData[binder.Name];
            // since ViewDataDictionary always returns a result even if the key does not exist, always return true
            return true;
        }

        public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            ViewData[binder.Name] = value;
            // you can always set a key in the dictionary so return true
            return true;
        }
    }
可以学习
Dynamic in C# 4.0: Creating Wrappers with DynamicObject
https://blogs.msdn.microsoft.com/csharpfaq/2009/10/19/dynamic-in-c-4-0-creating-wrappers-with-dynamicobject/


ShoppingCartController里面更新购物车, 继续购物， 结算等action都有属性ActionName("Cart")]， 默认情况下如果直接post， 会报错（多个action，不知道选择哪个）：
The current request for action 'Cart' on controller type 'ShoppingCartController' is ambiguous between the following action methods:
System.Web.Mvc.ActionResult UpdateCart(System.Web.Mvc.FormCollection) on type Nop.Web.Controllers.ShoppingCartController
System.Web.Mvc.ActionResult ContinueShopping() on type Nop.Web.Controllers.ShoppingCartController
System.Web.Mvc.ActionResult StartCheckout(System.Web.Mvc.FormCollection) on type Nop.Web.Controllers.ShoppingCartController
====》 用ActionMethodSelectorAttribute可以解决该问题, 继承该类, 重写IsValidForRequest
如 Nop.Web.Framework.Controllers, FormValueRequiredAttribute : ActionMethodSelectorAttribute
给相同的action， 加上该属性即可
[HttpPost, ActionName("Cart")]
[FormValueRequired("updatecart")]
public ActionResult UpdateCart(FormCollection form)

[HttpPost, ActionName("Cart")]
[FormValueRequired("continueshopping")]
public ActionResult ContinueShopping()
http://www.dotnetcurry.com/aspnet-mvc/724/handle-multiple-submit-buttons-aspnet-mvc-action-methods